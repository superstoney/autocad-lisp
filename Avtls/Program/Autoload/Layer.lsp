;视口加强
(defun c:vs()(c:VportsPlus))
(defun c:VportsPlus(/ layvp modevp)
	(defun layvp(/ msg pt1 pt2)
		(initget "P 2 3 4 N")
		(setq msg "\n指定矩形视口的角点或[多边形(P)/两垂直(2)/三靠右(3)/四等分(4)/新建(N)...]<进出>:")
		(setq pt1 (getpoint msg))
		(cond
			((null pt1) (av:msinout))
			((listp pt1)
				(setq pt2 (getcorner pt1))
				(command-s "vports" pt1 pt2)
			)
			((wcmatch (strcase pt1) "P") (command-s "vports" "P"))
			((wcmatch (strcase pt1) "2") (command-s "vports" "2" "V"))
			((wcmatch (strcase pt1) "3") (command-s "vports" "3" "R"))
			((wcmatch (strcase pt1) "4") (command-s "vports" "4"))
			((wcmatch pt1 "N")
				(vl-catch-all-apply 'initcommand-sversion)
				(command-s "vports")
			)
			(t nil)
		)
	)
	(defun modevp(/ key msg)
		(initget "2 3 4 N")
		(setq msg "\n选择视口[左键复原/两垂直(2)/三靠右(3)/四等分(4)/新建(N)...]<切换>:")
		(setq key (getpoint msg))
		(cond
			((null key) (command-s "-vports" "T"))
			((listp key) (command-s "vports" "SI"))
			((wcmatch (strcase key) "2") (command-s "vports" "2" "V"))
			((wcmatch (strcase key) "3") (command-s "vports" "3" "R"))
			((wcmatch (strcase key) "4") (command-s "vports" "4"))
			((wcmatch key "N")
				(vl-catch-all-apply 'initcommand-sversion)
				(command-s "vports")
			)
			(t nil)
		)
	)
	(princ "-->视口布置加强版")
	(setvar "cmdecho" 0)
	(cond
		((= (getvar "tilemode") 1) (modevp))
		(t (layvp))
	)
	(setvar "cmdecho" 1)
	(princ)
)
(defun av:msinout(/ msp)
	(setq msp (vla-get-mspace *doc*))
	(setq msp (if (equal msp :vlax-true) :vlax-false :vlax-true))
	(vla-put-MSpace *doc* msp)
)
(defun c:changespace(/ ss)
	(princ "-->转换空间")
	(setvar "CMDECHO" 0)
	(princ "\n将图纸空间的图形转换至模型空间，或者从模型空间转换至图纸空间，比例相应重置。")
	(if (equal (getvar "tilemode") 1)
		(progn
			(princ "\n本命令只能在布局中使用。")
			(setvar "TILEMODE" 0)
		)
	)
	(while (null (setq ss (ssget)))
		(av:msinout)
	)
	(command-s "chspace" ss)
	(setvar "CMDECHO" 1)
	(princ)
)
(defun c:m&pspace()
	(princ ">>>视口切换")
	(setvar "cmdecho" 0)
	(cond
		((= (getvar "tilemode") 1)
			(command-s "-vports" "T")
		)
		(t (av:msinout))
	)
	(setvar "cmdecho" 1)
	(princ)
)
(defun c:2e()(c:m&pspace))
(defun c:1e()
	(princ ">>>模型布局切换,")
	(setvar "tilemode" (abs (1- (getvar "tilemode"))))
	(princ)
)
(defun c:FastVports(/ *error* defsc h lay m mpt1 mpt2 msg n oldlay ppt1 ppt2 ppt21 ptlst sc str vplst w x y)
	(defun *error*(msg)
		(setvar "CLAYER" oldlay)
		(setvar "CMDECHO" 1)
		(princ)
	)
	(setq oldlay (getvar "clayer"))
	(setvar "nomutt" 0)
	(setvar "tilemode" 1)
	(setq n 0)
	(while (and
					 (setq n (1+ n))
					 (setq msg (strcat "\n请点选第" (itoa n) "个视口范围:"))
					 (setq mpt1 (getpoint msg))
					 (setq mpt2 (getcorner mpt1))
				 )
		(setq w (abs (- (car mpt2) (car mpt1))))
		(setq h (abs (- (cadr mpt2) (cadr mpt1))))
		(setq ptlst (list mpt1 mpt2 w h))
		(setq vplst (cons ptlst vplst))
	)
	(setq vplst (reverse vplst))
	(setvar "tilemode" 0) ;进入布局
	(vla-put-MSpace *doc* :vlax-false) ;退出视口
	(setvar "CMDECHO" 0)
	(setq lay "vports")
	(entmake (list
						 '(0 . "LAYER")
						 '(100 . "AcDbSymbolTableRecord")
						 '(100 . "AcDbLayerTableRecord")
						 '(70 . 0) ;是否冻结
						 '(6 . "Continuous")
						 (cons 2 lay) ;图层名
						 (cons 62 8) ;颜色
						 (cons 290 0) ;0不打印，1打印
					 )
	)
	(setvar "CLAYER" lay)
	(setq
		defsc 1.0
		*vportscs* (if *vportscs* *vportscs* defsc)
	)
	(setq n (itoa (1- n)) m 0)
	(foreach l vplst
		(setq str (if (> (setq m (1+ m)) 1) "<默认相邻右侧>" ""))
		(initget "S")
		;选择左下角
		(while (and
						 (setq msg (strcat "\n比例1:" (rtos *vportscs* 2 2) "[设置(S)] 请点选第" (itoa m) "/" n "个视口左下角:" str))
						 (setq ppt1 (getpoint msg))
						 (equal (type ppt1) 'STR)
						 (wcmatch "S" ppt1)
					 )
			(setq sc (getreal "\n确认图纸比例1:"))
			(setq *vportscs* (if sc sc defsc))
			(setq ppt1 nil)
		)
		;判断右上角
		(cond
			((and (null ppt1) (null ppt2))
				(exit)
			)
			((and (null ppt1) ppt2)
				(setq ppt1 ppt21)
			)
			(t nil)
		)
		;计算右上角
		(setq w (caddr l) h (cadddr l))
		(cond
			((listp ppt1)
				(setq
					x (car ppt1)
					y (cadr ppt1)
					ppt2 (list
								 (+ x (/ w *vportscs*))
								 (+ y (/ h *vportscs*))
								 0
							 )
				)
			)
			(t (exit))
		)
		(vl-cmdf "_mview" ppt1 ppt2)
		(setq ppt21 (list (car ppt2) y 0))
		;视口放大并锁定
		(vla-put-MSpace *doc* :vlax-true)
		(setq mpt1 (car l) mpt2 (cadr l))
		(vla-zoomwindow *acad* (vlax-3d-point mpt1) (vlax-3d-point mpt2))
		(vla-zoomscaled *acad* (/ 1 *vportscs*) acZoomScaledRelativePSpace)
		(vla-put-DisplayLocked
			(vla-get-ActivePViewport *doc*)
			:vlax-true
		)
		(vla-put-MSpace *doc* :vlax-false)
	)
	(*error* nil)
)
;显示特定视口
(defun c:actvp(/ n ss)
	(setvar "cmdecho" 0)
	(if (= (getvar "tilemode") 1) (setvar "tilemode" 0))
	(princ "\n请选择需要显示的特定视口(回车全显)")
	(cond
		((setq ss (ssget (list (cons 0 "viewport"))))
			(setq n (sslength ss))
			(setvar "maxactvp" (1+ n))
			(vl-cmdf "vports" "on" ss "")
		)
		(t (setvar "maxactvp" 64))
	)
	(setvar "cmdecho" 1)
	(princ)
)
;;=========================================================
(defun C:SK()(av:mviewlock :vlax-true))
(defun C:KS()(av:mviewlock :vlax-false))
;视口开关，参数为 :vlax-true 或 :vlax-false
(defun av:mviewlock (value / acadobject display displaylockedactive displaylockedall msg paperspacesel)
	;当前视口开关
	(defun displaylockedactive (value / pviewportobj)
		(setq pviewportObj (vla-get-ActivePViewport *doc*))
		(if (= (vla-get-DisplayLocked pviewportObj) display)
			(vla-put-DisplayLocked pviewportObj value)
		)
	)
	;全部视口开关
	(defun displaylockedall (value)
		(vlax-for pviewportObj paperSpaceSel
			(if (and
						(= (vla-get-ObjectName pviewportObj) "AcDbViewport")
						(= (vla-get-DisplayLocked pviewportObj) display)
					)
				(vla-put-DisplayLocked pviewportObj value)
			)
		)
	)
	;开始运行
	(setvar "cmdecho" 0)
	(if (= (getvar "tilemode") 1);判断是否在模型
		(progn
			(setvar "tilemode" 0);转至布局
			(princ "转至布局，如需返回模型，可命令1E。")
		)
	)
	(setq paperSpaceSel (vla-get-PaperSpace *doc*))
	(cond ;设置相应参数
		((= value :vlax-true)(setq display :vlax-false)(setq msg "：锁定"))
		((= value :vlax-false)(setq display :vlax-true)(setq msg "：解锁"))
		(t (princ "参数书写不正确！")(exit))
	)
	(if (= (getvar "cvport") 1)
		(progn (displaylockedall value)(princ "-->全部视窗"))
		(progn (displaylockedactive value)(princ "-->本激活视窗"))
	)
	(princ msg)
	(setvar "cmdecho" 1)
	(princ)
)
;;===============================================================================
;打开全部图层
(defun av:layeron-all()
	(vlax-for la (vla-get-Layers *doc*) (vla-put-layeron la :vlax-true))
)
;反显全部图层
(defun av:Layeron-Swap (/ val)
	(vlax-for la (vla-get-Layers *doc*)
		(setq val (1- (abs (vlax-get la 'LayerOn))))
		(vla-put-layeron la val)
	)
)
;开关指定图层
(defun av:Layeron(ss val / all ison iss lst n na)
	(vlax-for obj *layers* (setq all (cons obj all)))
	(while (or ss (setq ss (ssget)))
		(setq lst (list))
		(repeat (setq n (sslength ss))
			(setq n (1- n))
			(setq na (cdr (assoc 8 (entget (ssname ss n)))))
			(setq lst (cons na lst))
		)
		(setq lst (av:delstsame lst))
		(setq lst (mapcar (function (lambda(x) (vla-Item *layers* x))) lst))
		(foreach obj all
			(setq ison (equal :vlax-true (vla-get-LayerOn obj)))
			(setq iss (member obj lst))
			(cond
				((and val iss))
				((or (and val ison) iss)
					(vla-put-layeron obj :vlax-false)
				)
				(t nil)
			)
		)
		(setq ss nil)
	)
)
;;=================
;取得视窗中冻结隐藏的图层
(defun vp:getfreezelayer(/ ffg lyrlst ssent vpobj)
	(setq ffg (getvar "cvport"))
	(setq ssent (ssget "x" (list '(0 . "VIEWPORT") (cons 69 ffg))));取得激活视窗
	(setq vpobj (vlax-ename->vla-object (ssname ssent 0)))
	(vla-getxdata vpobj "acad" 'xt 'xd)
	(mapcar 'set '(xt xd) (list (safearray-value xt) (safearray-value xd)))
	(setq lyrlst (list))
	(mapcar '(lambda(a b) (if (= a 1003) (setq lyrlst (cons (variant-value b) lyrlst)))) xt xd)
	lyrlst
)
;;视口图层开关
(defun vp:layeron(ss val / all lst n la)
	(vlax-for obj *layers* (setq all (cons (vla-get-Name obj) all)))
	(while (or ss (setq ss (ssget)))
		(setq lst (list))
		(repeat (setq n (sslength ss))
			(setq n (1- n))
			(setq la (cdr (assoc 8 (entget (ssname ss n)))))
			(setq lst (cons la lst))
		)
		(setq lst (av:delstsame lst))
		(foreach l all
			(cond
				((and val (member l lst)))
				((or val (member l lst))
					(command-s "vplayer" "F" l "c" "")
				)
				(t nil)
			)
		)
		(setq ss nil)
	)
)
;;视口图层全开
(defun vp:layeron-all( / all frlst)
	(vlax-for obj *layers* (setq all (cons (vla-get-Name obj) all)))
	(setq frlst (vp:getfreezelayer))
	(foreach l all
		(if (member l frlst) (command-s "vplayer" "T" l "c" ""))
	)
)
;;=================
;关闭图层
(defun c:gg(/ istm ss)
	(princ "-->关闭特定图层!")
	(setvar "cmdecho" 0)
	(setq istm (= 1 (getvar "tilemode")))
	(princ "\n请选择关闭层：<回车全显>")
	(cond
		((and istm (setq ss (ssget)))
			(av:Layeron ss nil)
		)
		(istm (av:layeron-all))
		((setq ss (ssget)) (vp:layeron ss nil))
		(t (vp:layeron-all))
	)
	(setvar "CMDECHO" 1)
	(princ)
)
;打开全部图层
(defun c:qb(/ istm)
	(princ "-->打开所有图层!")
	(setvar "CMDECHO" 0)
	(setq istm (= 1 (getvar "tilemode")))
	(cond
		(istm (av:layeron-all))
		(t (vp:layeron-all))
	)
	(setvar "CMDECHO" 1)
	(princ)
)
;打开指定图层
(defun c:zd(/ all frlst istm la lst n ss)
	(princ "-->仅打开特定图层!")
	(setvar "CMDECHO" 0)
	(setq istm (= 1 (getvar "tilemode")))
	(cond
		(istm (av:layeron nil t))
		(t
			(setq ss (ssget))
			(repeat (setq n (sslength ss))
				(setq n (1- n))
				(setq la (cdr (assoc 8 (entget (ssname ss n)))))
				(setq lst (cons la lst))
			)
			(setq frlst (vp:getfreezelayer))
			(vlax-for obj *layers* (setq all (cons (vla-get-Name obj) all)))
			(foreach l all
				(cond
					((member l lst))
					((member l frlst))
					(t (command-s "vplayer" "F" l "c" ""))
				)
			)
		)
	)
	(setvar "CMDECHO" 1)
	(princ)
)
;反向图层显示
(defun c:fh(/ all frlst)
	(princ "-->反向关闭图层!")
	(setvar "CMDECHO" 0)
	(cond
		((= 1 (getvar "tilemode"))
			(av:layeron-swap)
		)
		(t
			(setq frlst (vp:getfreezelayer))
			(vlax-for obj *layers* (setq all (cons (vla-get-Name obj) all)))
			(foreach l all
				(cond
					((member l frlst)
						(command-s "vplayer" "T" l "c" "")
					)
					(T (command-s "vplayer" "F" l "c" ""))
				)
			)
		)
	)
	(setvar "CMDECHO" 1)
	(princ)
)
;====================================================================
(defun av:LayerLock(ss lock / islo lst n na obj)
	(setvar "CMDECHO" 0)
	(setvar "qaflags" 0);避免command命令出现弹窗
	(cond (lock) (t (princ "请选择解锁层：")))
	(while (or ss (setq ss (ssget)))
		(repeat (setq n (sslength ss))
			(setq n (1- n))
			(setq na (cdr (assoc 8 (entget (ssname ss n)))))
			(setq lst (cons na lst))
		)
		(setq lst (av:delstsame lst))
		(foreach la lst
			(setq obj (vla-Item *layers* la))
			(if (vl-string-search "#" la)
				(princ (strcat "\n图层< " la " >中包含特殊符号，无法识别，请修改图层名后重新操作！"))
			)
			(setq islo (equal :vlax-true (vla-get-Lock obj)))
			(cond
				((and lock islo))
				(lock
					(command-s "layer" "lo" la "")
					;(vla-put-Lock obj :vlax-true)
				)
				(islo
					(command-s "layer" "u" la "")
					;(vla-put-Lock obj :vlax-false)
				)
				(t nil)
			)
		)
		(setq ss nil)
	)
	(setvar "CMDECHO" 1)
	(princ)
)
;锁定指定图层
(defun c:layerlock(/ ss)
	(princ "\n请选择要锁定的图层：<回车解锁>")
	(if (setq ss (ssget))
		(av:LayerLock ss t)
		(av:LayerLock nil nil)
	)
)
;解锁指定图层
(defun C:LayerUnlock()(av:LayerLock nil nil))
;解锁所有图层
(defun c:LayerUnLockAll(/ la)
	(setvar "cmdecho" 0)
	(setvar "qaflags" 0)
	(vlax-for obj (vla-get-Layers *doc*)
		;(vla-put-Lock obj :vlax-false);无法显隐
		(setq la (vla-get-Name obj))
		(command-s "layer" "u" la "")
	)
	(setvar "cmdecho" 1)
	(princ)
)
;==========================================================
;冻结所选图层
(defun c:LayerFreeze(/ cl lst n na ss)
	(princ "请选择冻结层：<回车全解冻>")
	(cond
		((setq ss (ssget))
			(while (or ss (progn
											(princ "请选择冻结层：")
											(setq ss (ssget))
										)
						 )
				(setq lst (list))
				(repeat (setq n (sslength ss))
					(setq n (1- n))
					(setq na (cdr (assoc 8 (entget (ssname ss n)))))
					(setq lst (cons na lst))
				)
				(setq lst (av:delstsame lst))
				(cond
					((member (setq cl (getvar "clayer")) lst)
						(setq lst (vl-remove cl lst))
						(princ "已排除当前层\n")
					)
					(t nil)
				)
				(setq lst (mapcar (function (lambda(x) (vla-Item *layers* x))) lst))
				(foreach obj lst
					(vla-put-Freeze obj :vlax-true)
				)
				(setq ss nil)
			)
		)
		(t (c:LayerFreeAll))
	)
	(princ)
)
;解冻所有图层
(defun c:LayerFreeAll()
	(vlax-for la *layers*
		(and
			(= (vla-get-Freeze la) :vlax-true)
			(vla-put-Freeze la :vlax-false)
		)
	)
	(vla-Regen *doc* acAllViewports)
	(princ)
)
;反向冻结图层
(defun c:LayerFreeSwap(/ free)
	(vlax-for la *layers*
		(setq free (= (vla-get-Freeze la) :vlax-true))
		(vl-catch-all-apply 'vla-put-Freeze (list la (if free 0 1)))
	)
	(vla-Regen *doc* acAllViewports)
	(princ)
)
;;=========================================================
(defun c:hh() (c:Hideobj))
(defun c:Hideobj(/ n obj ss ssn)
	(princ "\n选择要隐藏的实体：<回车全显>")
	(cond
		((null (setq ss (ssget))) (c:Showall))
		(t
			(while (or ss (setq ss (ssget)))
				(repeat (setq n (sslength ss))
					(setq n (1- n))
					(setq ssn (ssname ss n))
					(setq obj (vl-catch-all-apply 'vlax-ename->vla-object (list ssn)))
					(vl-catch-all-apply 'vla-put-Visible (list obj :vlax-false))
				)
				(setq ss nil)
			)
		)
	)
	(princ)
)
;(c:Hideobj)
(defun c:Showall(/ n obj ss ssn)
	(setq ss (ssget "A"))
	(repeat (setq n (sslength ss))
		(setq n (1- n))
		(setq ssn (ssname ss n))
		(setq obj (vl-catch-all-apply 'vlax-ename->vla-object (list ssn)))
		(cond
			((vl-catch-all-error-p obj))
			((equal :vlax-true (vla-get-Visible obj)))
			(t (vl-catch-all-apply 'vla-put-Visible (list obj :vlax-true)))
		)
	)
)
;(c:Showall)
(defun c:HideSwap(/ n obj ss ssn val)
	(setq ss (ssget "A"))
	(repeat (setq n (sslength ss))
		(setq n (1- n))
		(setq ssn (ssname ss n))
		(setq obj (vlax-ename->vla-object ssn))
		(setq val (if (equal :vlax-true (vla-get-Visible obj)) :vlax-false :vlax-true))
		(vl-catch-all-apply 'vla-put-Visible (list obj val))
	)
)
;(c:HideSwap)
(defun c:isoobj(/ lst obj)
	(princ "\n选择隔离实体：")
	(while (setq lst (av:ss->ssnlst (ssget)))
		(foreach l (av:ss->ssnlst (ssget "A"))
			(cond
				((member l lst))
				((equal :vlax-false (vla-get-Visible (setq obj (vlax-ename->vla-object l)))))
				(t (vl-catch-all-apply 'vla-put-Visible (list obj :vlax-false)))
			)
		)
	)
)
;(c:isoobj)
;;=========================================================
;;释放所有
(defun c:LayerAllF()
	(av:Layeron-All);;;打开所有图层
	(c:LayerUnLockAll);;;解锁所有图层
	(c:LayerFreeAll);;;解冻所有图层
	(c:Showall);全显图元
)
(princ)
