(defun c:tableout(/ filter m ss str str1 str2)
	(setq filter '((0 . "LINE,LWPOLYLINE,*TEXT")))
	(cond
		((progn
			 (setq ss (ssget filter))
		 )
			(setq str1 "\n下列方案区别：1和2按表格线定位，3按文字本身定位。")
			(setq str2 "\n请选择输出方案[自下而上(1)/自上而下(2)/至粘贴板(3)]: <默认为2>")
			(setq str (strcat str1 str2))
			(setq m (cond ((getint str)) (t 2)))
			(cond
				((equal 3 m) (av:cad2clip ss))
				(t (av:cad2xlsofline ss m))
			)
		)
		(t nil)
	)
	(princ)
)
;====================================================================
;用特定程序打开表格文件
;(defun av:openxls(fn / app path reg-key val-name vla-data)
;	(setq reg-path "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\")
;	(setq xls "excel.exe")
;	;(setq xls "et.exe")
;	(setq app (findfile (vl-registry-read (strcat reg-path xls) "")))
;	(startapp app fn)
;)
;====================================================================
;第1种表格导出方案，根据表格线条判断内容
(defun av:cad2xlsofline(ss m / ent et f fn i j jd len lx lxc ly lyc m n name nlh nlm nlv ntxt stc str tab tj tx txt_ent ty x1 x2 y1 y2)
	(setq jd 0.1)
	(setq tab "\t")
	(setq ntxt 0 nlv 0 nlh 0)
	(setq lx () ly ())
	(setq txt_ent (ssadd))
	(setq n 0);序号的初值为0
	(setq nlm (sslength ss))
	(repeat nlm;重复执行，执行的次数等于所选对象的个数
		(setq ent (ssname ss n));得到选择集内第n个对象的图元名
		(setq et (entget ent));得到这个对象的图元表
		(setq name (cdr (assoc 0 et)))
		(if (or ;判断这个对象是否为文本
					(= (strcase "text") name)
					(= (strcase "mtext") name)
				)
			(progn
				(setq txt_ent (ssadd ent txt_ent))
				(setq ntxt (+ ntxt 1))
			)
		)
		(if (= (strcase "line") name);判断这个对象是否为直线
			(progn
				(setq x1 (nth 1 (assoc 10 et)))
				(setq x2 (nth 1 (assoc 11 et)))
				(setq y1 (nth 2 (assoc 10 et)))
				(setq y2 (nth 2 (assoc 11 et)))
				(setq lxc (fix (/ (+ x1 x2) 2)))
				(setq lyc (fix (/ (+ y1 y2) 2)))
				(if (< (abs (- x1 x2)) jd) (setq lx (cons lxc lx)))
				(if (< (abs (- y1 y2)) jd) (setq ly (cons lyc ly)))
			)
		)
		(setq n (+ n 1))
	)
	(setq lx (av:sort lx));将lx列表中的元素按顺序排列
	(setq ly (av:sort ly));将ly列表中的元素按顺序排列
	(setq lx (reverse lx))
	(if (= m 1) (setq ly (reverse ly)))
	(setq nlv (length lx))
	(setq nlh (length ly))
	(setq i 0)
	;新建文本
	(setq fn (vl-filename-mktemp nil nil ".xls"))
	(setq f (open fn "a"))
	(while (< i (- nlh 1))
		(setq str "")
		(setq j 0)
		(while (< j (- nlv 1))
			(setq n 0)
			(while (< n ntxt)
				(setq ent (ssname txt_ent n))
				(setq et (entget ent))
				(setq tx (nth 1 (assoc 10 et)))
				(setq ty (nth 2 (assoc 10 et)))
				(if (= m 1)
					(setq tj (and (> ty (nth i ly)) (< ty (nth (+ i 1) ly))))
					(setq tj (and (< ty (nth i ly)) (> ty (nth (+ i 1) ly))))
				)
				(if (and (> (+ tx 1) (nth j lx)) (< (+ tx 1) (nth (+ j 1) lx)) tj)
					(progn
						(setq txt_ent (ssdel ent txt_ent))
						(setq ntxt (- ntxt 1))
						(setq n ntxt)
						(setq stc (cdr (assoc 1 et)))
						(setq len (strlen stc))
						(if (> len 2) (setq stc (av:eliminate stc len)))
					)
				)
				(setq n (+ n 1))
			)
			(if (= n ntxt) (setq stc ""))
			(setq str (strcat str stc))
			(if (/= j (- nlv 2)) (setq str (strcat str tab)))
			(setq j (+ j 1))
		)
		(write-line str f)
		(setq i (+ i 1))
	)
	(close f)
	(vlax-invoke (vlax-get-or-create-object "wscript.shell") 'run fn)
)
(defun av:fdelete(str1 str2 / k len1 len2 stle stre strk strq)
	(setq len1 (strlen str1))
	(setq len2 (strlen str2))
	(if (>= len1 len2)
		(progn
			(setq k 1)
			(while (< k (+ (- len1 len2) 2))
				(setq strk (substr str1 k len2))
				(if (= strk str2)
					(progn
						(setq strq (substr str1 1 (- k 1)))
						(setq stre (substr str1 (+ k len2)))
						(if (= str2 "\U+03C6")(progn(setq str1 (strcat strq "φ" stre))(setq len1 (- len1 6))))
						(if (= str2 "\U+00D7")(progn(setq str1 (strcat strq "×" stre))(setq len1 (- len1 6))))
						(if (= str2 "\U+0082")(progn(setq str1 (strcat strq "A" stre))(setq len1 (- len1 6))))
						(if (= str2 "\U+0083")(progn(setq str1 (strcat strq "B" stre))(setq len1 (- len1 6))))
						(if (= str2 "\U+0084")(progn(setq str1 (strcat strq "C" stre))(setq len1 (- len1 6))))
						(if (= str2 "\\P")(progn(setq str1 (strcat strq stre))(setq len1 (- len1 2))))
						(if (= str2 "\t")(progn(setq str1 (strcat strq stre))(setq len1 (- len1 2))))
						(if (or(= str2 "{")(= str2 "}"))(progn(setq str1 (strcat strq stre))(setq len1 (- len1 1))))
					)
				)
				(setq k (+ k 1))
			)
		)
	)
	(setq stle len1)
	(setq str1 str1)
)
(defun av:eliminate(strc stle / is js stre strq)
	;消除strc中的"φ"和"×"
	(if (> stle 7)
		(progn
			(setq strc (av:fdelete strc "\U+03C6"))
			(setq strc (av:fdelete strc "\U+00D7"))
			(setq strc (av:fdelete strc "\U+0082"))
			(setq strc (av:fdelete strc "\U+0083"))
			(setq strc (av:fdelete strc "\U+0084"))
		)
	)
	(if (> stle 2)
		(progn
			(setq strc (av:fdelete strc "\\P"))
			(setq strc (av:fdelete strc "\t"))
			(setq strc (av:fdelete strc "{"))
			(setq strc (av:fdelete strc "}"))
		)
	)
	;消除strc中"\...;"的内容
	(setq is 1)
	(while (< is stle)
		(if (= (substr strc is 1) "\\")
			(progn
				(setq js (+ is 1))
				(while (<= js stle)
					(if (= (substr strc js 1) ";")
						(progn
							(setq strq (substr strc 1 (- is 1)))
							(setq stre (substr strc (+ js 1)))
							(setq strc (strcat strq stre))
							(setq stle (strlen strc))
							(setq js stle)
							(setq is (- is 1))
						)
					)
					(setq js (+ js 1))
				)
			)
		)
		(setq is (+ is 1))
	)
	(setq strc strc)
)
(defun av:sort(lxy / i lxy_n max_xy nxy xy_max xy_min);排序函数
	(setq nxy (length lxy))
	(setq xy_min (apply 'min lxy))
	(setq xy_max (apply 'max lxy))
	(setq max_xy (+ xy_max 10))
	(setq lxy_n (list xy_min))
	(setq lxy (subst max_xy xy_min lxy))
	(setq i 0)
	(while (< i (- nxy 1))
		(setq xy_min (apply 'min lxy))
		(setq lxy (subst max_xy xy_min lxy))
		(setq lxy_n (cons xy_min lxy_n))
		(if (= xy_min xy_max) (setq i nxy))
		(setq i (+ i 1))
	)
	(setq lxy lxy_n)
)
;=====================================================================
;第2种表格导出方式，靠文本自身位置定位
(defun av:cad2clip (ss / compare_t m max_t n nr_list nt_list oj_list oj_name oj_num pt1 pt2 r_list row_list row_num row_t t_list t_num text train_list train_num x1 x2 xls_row xls_text xls_train xx1 xx2 y y1 y2 yy1 yy2)
	(cond
		(ss (setq ss (ssget "p" '((0 . "text,mtext")))))
		(t (setq ss (ssget '((0 . "text,mtext")))))
	)
	;获取文字范围列表t_list
	(setq oj_list nil)
	(repeat (setq oj_num (sslength ss))
		(setq oj_name (ssname ss (setq oj_num (1- oj_num))))
		(vla-getboundingbox (vlax-ename->vla-object oj_name) 'pt1 'pt2)
		(setq pt1 (vlax-safearray->list pt1))
		(setq pt2 (vlax-safearray->list pt2))
		(setq x1 (min (car pt1) (car pt2)))
		(setq x2 (max (car pt1) (car pt2)))
		(setq y1 (min (cadr pt1) (cadr pt2)))
		(setq y2 (max (cadr pt1) (cadr pt2)))
		(setq oj_list (cons (list x1 x2 y1 y2 oj_name) oj_list))
	)
	;对文字分行,得到表xls_row，文字分列由左至右排列
	(setq t_list oj_list xls_row nil row_list nil)
	(while t_list
		;获取y值最大的文字
		(setq max_t (nth 0 t_list) nt_list nil)
		(repeat (1- (setq t_num (length t_list)))
			(setq compare_t (nth (setq t_num (1- t_num)) t_list))
			(setq y1 (caddr max_t) yy1 (caddr compare_t));end setq
			(if (< y1 yy1)
				(setq nt_list (cons max_t nt_list) max_t compare_t)
				(setq nt_list (cons compare_t nt_list))
			)
		)
		(setq t_list nt_list)
		;获取与max_t 同行的文字
		(setq row_list (list max_t) nt_list nil)
		(repeat (setq t_num (length t_list))
			(setq compare_t (nth (setq t_num (1- t_num)) t_list))
			(setq y1 (caddr max_t) yy2 (cadddr compare_t))
			(if (> yy2 y1)
				(setq row_list (cons compare_t row_list))
				(setq nt_list (cons compare_t nt_list))
			)
		)
		(setq t_list nt_list)
		;同行文字按x右左至右排序
		(setq r_list row_list row_list nil)
		(while r_list
			(setq max_t (nth 0 r_list) nr_list nil)
			(repeat (1- (setq t_num (length r_list)))
				(setq compare_t (nth (setq t_num (1- t_num)) r_list))
				(setq x1 (car max_t) xx1 (car compare_t))
				(if (< x1 xx1)
					(setq nr_list (cons max_t nr_list) max_t compare_t)
					(setq nr_list (cons compare_t nr_list))
				)
			)
			(setq r_list nr_list)
			(setq row_list (cons max_t row_list))
		)
		(setq xls_row (cons row_list xls_row))
	)
	;对文字分列,得到表xls_train，文字分列由左至右排列
	(setq t_list oj_list xls_train nil train_list nil)
	(while t_list
		;获取y值最大的文字
		(setq max_t (nth 0 t_list) nt_list nil)
		(repeat (1- (setq t_num (length t_list)))
			(setq compare_t (nth (setq t_num (1- t_num)) t_list))
			(setq x1 (car max_t) xx1 (car compare_t))
			(if (< x1 xx1)
				(setq nt_list (cons max_t nt_list) max_t compare_t)
				(setq nt_list (cons compare_t nt_list))
			)
		)
		(setq t_list nt_list)
		;获取与max_t 同行的文字
		(setq train_list (list max_t) nt_list nil)
		(repeat (setq t_num (length t_list))
			(setq compare_t (nth (setq t_num (1- t_num)) t_list))
			(setq x1 (car max_t) xx2 (cadr compare_t))
			(if (> xx2 x1)
				(setq train_list (cons compare_t train_list))
				(setq nt_list (cons compare_t nt_list))
			)
		)
		(setq t_list nt_list)
		(setq xls_train (cons train_list xls_train))
	)
	;转化为xls_text文字段落
	(setq xls_text "")
	(repeat (setq row_num (length xls_row))
		(setq row_list (nth (setq row_num (1- row_num)) xls_row))
		(setq n -1 m 0)
		(repeat (length row_list)
			(setq row_t (nth (setq n (1+ n)) row_list))
			;查找row_t的列数train_num
			(setq
				train_num -1
				y nil
			)
			(while (= y nil)
				(setq train_list (nth (setq train_num (1+ train_num)) xls_train))
				(if (member row_t train_list) (setq y 1))
			)
			;(setq train_num (1+ train_num ))
			;判断列数是否正确，添加tab
			(setq oj_name (car (cdr (cdddr row_t))))
			(setq text (vla-get-textstring (vlax-ename->vla-object oj_name)))
			;把cad的通配符改回数学符号
			(setq text (vl-string-subst  "°" "%%d" text))
			(setq text (vl-string-subst  "°" "%%d" text))
			(setq text (vl-string-subst  "±" "%%p" text))
			(setq text (vl-string-subst  "±" "%%p" text))
			(setq text (vl-string-subst  "φ" "%%c" text))
			(setq text (vl-string-subst  "φ" "%%c" text))
			(repeat m (setq train_num (1- train_num)))
			(while (< n train_num)
				(setq xls_text (strcat xls_text "\t"))
				(setq train_num (1- train_num))
				(setq m (1+ m))
			)
			(if (= n 0)
				(setq xls_text (strcat xls_text (strcat "\"" text "\"")))
				(setq xls_text (strcat xls_text (strcat "\t\"" text "\"")))
			)
		)
		(setq xls_text (strcat xls_text (strcat "\n")))
	)
	;删除最后一个空格
	(setq xls_text (substr xls_text 1 (- (strlen xls_text) 1)))
	(av:putcliptext xls_text);文字送剪贴板
	(princ "\n已拷贝至剪贴板，请在execl里直接粘贴！")
)


(princ)







